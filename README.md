[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/qcWcnElX)

# Java concurrency

# Цели и задачи л/р:

Задача об обедающих философах:

Рассмотрим семь программистов, сидящих вокруг круглого стола для обеда.
У каждого программиста есть тарелка супа перед ним, а между каждой парой программистов находится ложка.
Однако, чтобы поесть суп, программисту необходимо взять две ложки - справа и слева (он очень голодный).
Когда программист поедает суп, ложки остаются занятыми и не могут быть использованы соседними программистами.
Программисты чередуют прием еды с обсуждением преподавателей.
Когда суп заканчивается, программист просит одного из двух официантов принести ему еще одну порцию (то есть тарелка супа
ограничена).
Всего в ресторане есть 1_000_000 порций еды, после чего обед заканчивается.
Все программисты должны поесть +- одинаково, чтобы никому не было обидно

Ваша задача - реализовать симуляцию обеда с использованием языка программирования Java и многопоточности.
Каждый программист должен быть представлен в виде потока, а ложки - в виде общих ресурсов, которые программисты могут
захватывать и освобождать.
Также не забудьте про официантов и запасы еды.

Дополнительное условие -- количество программистов, еды и официантов должно быть параметризируемое.

[Это усложнение классической задачи, про которую можно почитать тут](https://en.wikipedia.org/wiki/Dining_philosophers_problem)

Необходимо обеспечить корректное выполнение программы, чтобы избежать состояний взаимной блокировки и гарантировать, что
каждый программист получит возможность поесть.

# Обязательное условие:

* Использование системы сборки Gradle
* Код должен быть отлажен и протестирован

# Дедлайн 08.10.2025 23:59

# Решения

## 1. Упорядочивание блокировок

Решение заключается в том, что последний студент захватывает ложку в другом порядке.
Если все сначала захватывают левую ложку, а затем правую, то последний студент захватывает правую ложку, а затем левую.

Такое решение **не** обеспечивает fairness (все студенты поедят одинаково).

Ниже рассмотрены различные варианты вокруг этого подхода.

### 1.1. Добавление различных задержек

Решение дает fairness в случае, когда работа **вне** критической секции дольше работы внутри критической секции.

Это обосновывается тем, что студенты не конкурируют за захват ресурса.

```java
        var config = Config.builder()
        .NUMBER_OF_STUDENTS(7)
        .NUMBER_OF_SOUP(10_000)
        .NUMBER_OF_WAITERS(2)
        .TIME_TO_EAT_SOUP_MS(Eat Delay)
        .TIME_TO_SPEAK_MS(Speak Delay)
        .FAIR_IF_POSSIBLE(false)
        .build();
```

| Speak Delay | Eat Delay | Fairness Array                             |
|-------------|-----------|--------------------------------------------|
| 0           | 0         | [219, 403, 771, 1505, 1778, 5144, 180]     |
| 0           | 1         | [574, 858, 1062, 1711, 1862, 3430, 503]    |
| 1           | 0         | [1428, 1430, 1428, 1427, 1428, 1430, 1429] |
| 1           | 1         | [1292, 1457, 1481, 1490, 1492, 1496, 1292] |
| 2           | 1         | [1428, 1428, 1429, 1429, 1429, 1429, 1428] |

### 1.2. Использование параметра `fair` в Java API

У классов ReentrantLock и ArrayBlockingQueue есть параметр `fair`, который позволяет гарантировать "честность" при
захвате ресурсов, в моем случае это **почему-то** полностью не решает проблему, но значительно улучшает честность.

При этом стоит помнить, что fairness небесплатная, для демонстрации этого эффекта был реализован JMH
`OrderedLocksTests`, для запуска следует добавить gradlew права на исполнение (`sudo chmod +x ./gradlew`) и вызвать
`./gradlew jmh`. В тесте использовались задержки равные 0. Результат теста будет в `./build/results/jmh/results.txt`.

Результаты на моей машине (MAC M2 MAX 32GB):

```text
Benchmark                               Mode  Cnt    Score    Error  Units
OrderedLocksTests.zeroDelayFairTest     avgt    5  171.625 ± 13.561  ms/op
OrderedLocksTests.zeroDelayNonFairTest  avgt    5  105.592 ± 27.446  ms/op
```

| fair  | fairness array                             |
|-------|--------------------------------------------|
| false | [227, 433, 724, 1483, 1690, 5291, 152]     |
| true  | [1179, 1301, 1249, 1333, 1434, 2322, 1182] |
